suppressWarnings(rm(a,adStats,anovaDF,anovaMatrix,anovaTable,autocorrBarPlot,autocorrDigits,autocorrExport,autocorrLags,autocorrTable,autocorrValues,autoDF,cDigits,classStats,classTable,coeffdf,coeffDigits,coeffMatrix,coeffTable,coeffTableExcel,coeffStars,constantInd,cutoffValue,errorStats,errorStatsTable1,errorStatsTable2,expCoeff,foldNum,fValues,has,i,indVariables,logitAUC,logitRsquared,logitStats,mainTitle,maxError,minError,modelAdjRsquared,modelRsquared,modelAIC,modelCV,modelDescription,modelDev,modelDf,modelEquation,modelInfo,modelMAE,modelMAPE,modelMASE,modelName,modelNumber,modelRsqStdErr,modelSize,modelStdErr,modelsummarydf,modelSummaryDigits,modelSummaryTable,modelSummaryTableExport,MSdigits,nData,newColumn,nFolds,nIterations,nLags,nMissing,nonMissing,nTest,nTrain,nullModel,nVariables,outputExcel,regData,regModel,regScript,regStats,regY,residualDf,RMSEdigits,RMSEnull,RMSEnulltest,RMSEtest,RMSEtrain,roccurve,rowNumbers,stepInfo,SSdigits,SSregression,SSresidual,SStotal,stdCoeffValues,testClass,testClassTable,testData,testErrors,testMethod,testPctCor,testPred,testRMSEratio,testRsquared,testSet,testSetName,testStats,testStatsExport,testStatsValues,testTable,testTableExport,testTableOmitMV,testTitle,testTrueNeg,testTruePos,testValues,trainClass,trainData,trainErrors,trainPctCor,trainPred,trainSet,trainSetName,trainStats,trainStatsExport,trainStatsValues,trainTable,trainTableExport,trainTrueNeg,trainTruePos,tValue,variableSelection,vifValues,wants,x,yFitted,yMax,yMin,yName,yResids,yValues))writeLines(" -----Begin script GLOWdata3.Model.3.04.29.22.37.34.r produced by RegressItLogistic version 2022.12.14 on DESKTOP-F9IAE9K at time 04.29.22.37.34 ")writeLines(" ")modelDescription <- "Linear regression model Model.3 for FRACTURE in data frame GLOWdata3 " writeLines(modelDescription)variableSelection <- "Variable selection:  all " writeLines(variableSelection)testMethod <- "Out-of-sample test:  fixed with testing set  " writeLines(testMethod)Model.3 <- lm(FRACTURE ~ 1, data = trainData)constantInd <- 1stepInfo <- "" regModel <- Model.3modelName <- "Model.3" trainPred <- predict(regModel, trainData, se.fit= T, type = "response", interval = "prediction", level = .95)trainErrors <- residuals(regModel, trainData, type = "response", interval = "prediction", level = .95)# ----- table of training-set actual and predicted values, residuals, standardized residuals, absolute standardized residuals, leverages, and Cook's DtrainTable <- cbind(na.omit(cbind(trainSet, regY[trainSet],trainPred$fit,trainPred$se.fit)),summary(regModel)$residuals, rstandard(regModel),abs(rstandard(regModel)),hatvalues(regModel),cooks.distance(regModel))# ----- more variables are created for later referencenMissing <- nTrain - dim(trainTable)[1]nTrain <- dim(trainTable)[1]yValues <- trainTable[,2]yFitted <- trainTable[,3]yResids <- trainTable[,7]RMSEtrain <- (var(trainErrors) * (nTrain - 1) / nTrain + mean(trainErrors) ^ 2) ^ 0.5RMSEdigits <- max(0, round(4 - log10(RMSEtrain)))   # number of significant digits to use for rounding some statistics in tablesRMSEnull <- (var(yValues)* (nTrain - 1) / nTrain) ^ 0.5 colnames(trainTable) <- c("Train Row#", "Actual", "Predicted", "Lower95%", "Upper95%", "Std.Error.M","Residual", "Std.Res.", "AbsStdRes", "Leverage", "Cooks D")nVariables <- regModel$rankmodelInfo <- paste(modelName,"for",yName,"(",nVariables - constantInd,"variable(s),",stepInfo,"n=",nTrain,")")# ----- build table of training set results for exporting to ExceltrainTableExport <- rbind(c("Train Row#", "Actual", "Predicted", "Lower95%", "Upper95%", "Std.Error.M","Residual", "Std.Res.", "AbsStdRes", "Leverage", "Cooks D"),trainTable)colnames(trainTableExport) <- rep("",11)trainTableExport <- rbind(c(paste("Fitted Values:",modelInfo),rep("",7),nTrain,rep("",2)),trainTableExport)trainTableExport <- rbind(rep("",11),trainTableExport)testPred <- predict(regModel, testData, se.fit= T, type = "response", interval = "prediction", level = .95)testErrors <- regY[testSet] - testPred$fit[,1]# ----- table of test-set actual and predicted values, standard errors, errors, standardized and absolute standardized errorstestTable <- cbind(testSet, regY[testSet], testPred$fit, testPred$se.fit, testErrors, testErrors/summary(regModel)$sigma,abs(testErrors/summary(regModel)$sigma))testErrors <- na.omit(testTable[,7])nTest <- length(testErrors)RMSEtest <- (var(testErrors) * (nTest - 1) / nTest + mean(testErrors) ^ 2) ^ 0.5testValues <- na.omit(as.matrix(testTable[, c(2,3)]))[,1]RMSEnulltest <- (var(testValues) * (nTest - 1) / nTest)^.5testRMSEratio <- RMSEtest/RMSEnulltesttestRsquared <- 1-testRMSEratio^2colnames(testTable) <- c("Test Row#", "Actual","Predicted", "Lower95%","Upper95%","Std.Error.M", "Error", "Std.Res.", "AbsStdRes")# ----- build table of test set results for exporting to ExceltestTableExport <- rbind(c("Test Row#", "Actual", "Predicted", "Lower95%","Upper95%", "Std.Error.M","Residual", "Std.Res.", "AbsStdRes"),testTable)colnames(testTableExport) <- rep("",9)testTableExport <- rbind(c(paste("Test/Forecast Values:",modelInfo),rep("",7),dim(testTableExport)[1]-1),testTableExport)testTableExport <- rbind(rep("",9),testTableExport)testTableExport <- cbind(testTableExport,matrix("", nrow=dim(testTableExport)[1],ncol=2))residualDf <- regModel$df.residualtValue <- qt(0.975, residualDf)SSregression <- sum((yFitted-mean(yFitted))^2)SSresidual <- sum((yResids-mean(yResids))^2)SStotal <- sum((yValues-mean(yValues))^2)modelAdjRsquared <- summary.lm(regModel)$adj.r.squaredmodelRsquared <- summary.lm(regModel)$r.squaredmodelStdErr <- summary.lm(regModel)$sigmamodelMASE <- NAregStats  <- t(matrix(c(summary.lm(regModel)$r.squared, summary.lm(regModel)$adj.r.squared,regModel$df.residual,summary.lm(regModel)$sigma, sd(yValues),mean(yValues),nTrain,length(trainSet)-nTrain))) writeLines(" ")print(regModel$call)writeLines(" ")writeLines(paste("Regression statistics:",modelName,"for",yName,"(#variables =",nVariables-1,")"))# ----- Anderson-Darling statistic (normality test) and additional error statisticsadStats <- ad.test(trainErrors) minError <- min(trainErrors)maxError <- max(trainErrors)modelMAE <- mae(yFitted,yValues)modelMAPE <- mape(yValues,yFitted) # ----- calculate variance inflation factors and standarized coefficients if the model includes a constant and has more than one independent variablevifValues <- NA stdCoeffValues <- NA if(grepl("Int", variable.names(regModel)[1]) & nVariables > 1){ vifValues <- c(0,vif(regModel)) stdCoeffValues <- lm.beta(regModel)$standardized.coefficients } RMSEdigits <- max(0, round(4 - log10(summary.lm(regModel)$sigma)))modelAIC <- extractAIC(regModel)[2]print(kable(regStats,col.names=c("R-Sqr","Adj R-Sqr","Df","StdErrReg","StdDepVar","MeanDepVar","#Fitted","#Missing"),digits = c(3,3,0,RMSEdigits,RMSEdigits,RMSEdigits,0,0))) # ----- build a customized coefficient table including variance inflation factors and standardized coefficientscoeffMatrix <- cbind(summary.lm(regModel)$coefficients,vifValues,stdCoeffValues)writeLines("")writeLines(paste("Coefficient estimates:",modelName,"for",yName,"(#variables =",nVariables-1,")"))colnames(coeffMatrix ) <- c( "Coeff","StdErr","t stat","P(>_t_)","VIF","StdCoeff")  #   underscores around t will be converted to vertical barscDigits <- max(pmax(0,round(3 - log10(coeffMatrix[,2]),0)))coeffTable <-gsub("_","|",kable(coeffMatrix, digits = c(cDigits,cDigits,3,3,1,3)))coeffTable <- gsub("NA","  ",coeffTable)colnames(coeffTable) <- NULLprint(coeffTable, row.names = F)writeLines(" ")writeLines(paste("Error distribution statistics:",modelName,"for",yName,"(#variables =",nVariables-1,")"))errorStats  <- t(matrix(c(nTrain,mean(trainErrors),RMSEtrain,modelMAE,minError,quantile(trainErrors, c(.25, .5, .75)),maxError)))rownames(errorStats) <- "Fitted" if(nTest > 0){testTableOmitMV <- na.omit(testTable) errorStats  <- rbind(errorStats,t(matrix(c(nTest,mean(testErrors),RMSEtest,mae(testTableOmitMV[,3],testTableOmitMV[,2]),min(testErrors),quantile(testErrors, c(.25, .5, .75)),max(testErrors)))))  rownames(errorStats) <- c("Train","Test")print(gsub("NA","  ",kable(errorStats,col.names=c("#","MeanErr","RMSE","MAE","Min","25%","50%","75%","Max"),digits = c(1,rep(RMSEdigits,8)))))writeLines(" ")writeLines(paste("Test RMSE/Train RMSE =",round(RMSEtest/RMSEtrain,3)))} else {print(kable(errorStats,col.names=c("#","MeanErr","RMSE","MAE","Min","25%","50%","75%","Max"),digits = c(1,rep(RMSEdigits,8))))}writeLines(" ")writeLines(paste("Residual skewness =",round(skewness(trainErrors),3),", kurtosis =",round(kurtosis(trainErrors),3),", A-D stat =",round(as.numeric(adStats[1]),2),"(P =",format(round(as.numeric(adStats[2]),3),nsmall = 3),")"))writeLines(" ")writeLines("Correlation matrix of coefficient estimates ")writeLines(" ")print(cov2cor(vcov(regModel)))# ----- build single-row table of error statistics in training period errorStats <- t(matrix(c(nTrain,mean(yValues),sd(yValues),min(yValues),max(yValues))))rownames(errorStats) <- yNameif(nTest>0){# ----- add 2nd row with error statistics in test period errorStats <- rbind(errorStats,c(nTest,mean(testValues),sd(testValues),min(testValues),max(testValues)))rownames(errorStats) <- c("Train","Test")}writeLines(" ")writeLines(" ")writeLines("Summary statistics of dependent variable:")print(kable(errorStats, col.names = c("#","Mean","StdDev","Min","Max"),digits = c(1,rep(RMSEdigits-1,4))))writeLines(" ")if(nTest>0){writeLines(paste("Test StdDev/Train StdDev =",round(sd(testValues)/sd(yValues),3)))}testTitle = ":  single test" trainSetName = "Train " testSetName = "Test" mainTitle = paste(modelName," for ",yName,testTitle)modelSize <- paste("n=", nTrain, ", #var=",length(regModel$coefficients)-1,", ")layout(matrix(c(1,2,3,4),2,2))plot(regModel, main = mainTitle, cex.main = 0.95)layout(matrix(c(1,2,3),3,1))yMin <- min(na.omit(regY),yValues,yFitted, na.omit(testTable[,2]),na.omit(testTable[,3]))yMax <- max(na.omit(regY),yValues,yFitted, na.omit(testTable[,2]),na.omit(testTable[,3]))plot(c(trainTable[,1],testTable[,1]),c(yValues,testTable[,2]),main=mainTitle, type = "o", col = "black",lty=0, xlab = NA , ylab= yName, cex.main = 0.95, ylim = c(yMin,yMax))title(main = ( paste(modelSize, trainSetName, "RMSE=",round(RMSEtrain,RMSEdigits), ", ",testSetName," RMSE=", round(RMSEtest,RMSEdigits))),  line = 0.5, cex.main = 0.8)points(trainTable[,1],yFitted,pch = 16, col = "red",cex=1)points(testTable[,1],testTable[,3],pch = 17, col = "blue",lty=3,cex=1)barplot(yResids,main=mainTitle,xlab = NA, ylab= "Residual", cex.main=0.95)title(sub = paste(modelSize, trainSetName, "RMSE=",round(RMSEtrain,RMSEdigits), ", ",testSetName," RMSE=", round(RMSEtest,RMSEdigits)), cex.sub = 0.8)  # ----- build a text string with the model equationmodelEquation <- paste("Model.3 <- lm(",as.character(formula(Model.3)[2])," ~ ",paste(names(coef(Model.3)), collapse='+'),",data = GLOWdata3)") modelEquation <- sub("(Intercept)+","",modelEquation,fixed=TRUE)#  ----- start building 9-column matrix of output for ExceloutputExcel  <- c("Model:", modelName,rep("",2),"Mean:","R Script:",regScript,rep("",4),1) outputExcel  <- rbind(outputExcel,(c("Dependent Variable:","",yName,"",mean(yValues),testMethod,rep("",5),2))) outputExcel  <- rbind(outputExcel,(c("Independent Variables:",rep("",4),variableSelection,rep("",5),3))) indVariables <- paste(names(coef(regModel)),collapse = ",")   #  extract list of independent variables for cell A4 on spreadsheetindVariables <- sub("(),","",indVariables) indVariables <- gsub("\\(","",indVariables) indVariables <- gsub("\\)","",indVariables) outputExcel  <- rbind(outputExcel,(c(indVariables,rep("" ,10),4))) outputExcel  <- rbind(outputExcel,(c("Equation:",rep("", 10),5))) outputExcel  <- rbind(outputExcel,(c(modelEquation,rep("", 10),6))) outputExcel  <- rbind(outputExcel,(c(rep("", 12)))) outputExcel  <- rbind(outputExcel,(c(paste("Regression Statistics:",modelInfo),rep("", 10),8))) outputExcel  <- rbind(outputExcel,(c("","R-Squared","Adj.R-Sqr.","Std.Err.Reg.","Std.Dep.Var","#Fitted","#Missing","Critical t","Confidence","","",9))) outputExcel  <- rbind(outputExcel,(c("",summary.lm(regModel)$r.squared, summary.lm(regModel)$adj.r.squared, summary.lm(regModel)$sigma, sd(yValues),nTrain,nMissing,tValue,.95,"","",10))) outputExcel  <- rbind(outputExcel,(c(rep("", 12)))) outputExcel  <- rbind(outputExcel,(c(paste("Coefficient Estimates:",modelInfo),rep("", 10),12))) outputExcel  <- rbind(outputExcel,(c("Variable","Coefficient","Std.Err.","t statistic","P value","Lower95%","Upper95%","VIF","Std.Coeff.","","",13))) #   -----  build the coefficient tablecoeffTableExcel  <-  cbind(variable.names(regModel),summary.lm(regModel)$coefficients[,1],summary.lm(regModel)$coefficients[,2],summary.lm(regModel)$coefficients[,3],summary.lm(regModel)$coefficients[,4],confint(regModel, level = .95),vifValues,stdCoeffValues) colnames(coeffTableExcel) <- c("Variable","Coefficient","Std.Err.","t statistic","P value","Lower95%","Upper95%","VIF","Std.Coeff.")outputExcel[4,] <- sub("Intercept","", outputExcel[4,]) #  remove intercept from list of independent variables in cell A4coeffTableExcel[1,] <- sub("(Intercept)", "Constant",coeffTableExcel[1,]) # change name of intercept to constant in coefficient table coeffTableExcel[1,] <- gsub("\\(", " ", coeffTableExcel[1,]) # convert dummy variable notation to .Eq. rather than (.) coeffTableExcel <- gsub("\\)", ".Eq.", coeffTableExcel) coeffTableExcel[1,] <- sub("Constant.Eq.", "Constant",coeffTableExcel[1,]) # undo incidental changes to constant labelcoeffTableExcel <- gsub("\\(", "", coeffTableExcel) coeffTableExcel <- sub("factor", "", coeffTableExcel) coeffTableExcel <- cbind(coeffTableExcel,rep("",nVariables),rep("",nVariables),rep(14,nVariables)) outputExcel  <- rbind(outputExcel,coeffTableExcel) outputExcel  <- rbind(outputExcel,(c(rep("", 12))))outputExcel  <- rbind(outputExcel,(c(rep("", 12))))outputExcel  <- rbind(outputExcel,(c(rep("", 12)))) outputExcel  <- rbind(outputExcel,(c(paste("Error Distribution Statistics:",modelInfo),rep("", 10),22))) outputExcel  <- rbind(outputExcel,(c("","Mean Error","RMSE","MAE","Min","Max","MAPE","A-D* stat","MASE","","",23))) outputExcel  <- rbind(outputExcel,(c(paste("Fitted (n=",nTrain,")"),mean(trainErrors),RMSEtrain,modelMAE,min(trainErrors),max(trainErrors),modelMAPE,paste(round(as.numeric(adStats[1]),2),"(",format(round(as.numeric(adStats[2]),3)),")"),modelMASE,"","",24)))if(nTest > 0){testTableOmitMV <- na.omit(testTable) #  omit missing values in test table for mean absolute error calculation (mae function from metrics package)outputExcel  <- rbind(outputExcel,(c(paste("Tested (n=",nTest,")"),mean(testErrors),RMSEtest,mae(testTableOmitMV[,3],testTableOmitMV[,2]),min(testErrors),max(testErrors),rep("",5),25 )))outputExcel  <- rbind(outputExcel,(c(rep("", 12)))) outputExcel  <- rbind(outputExcel,(c(testMethod,rep("", 10),27)))outputExcel  <- rbind(outputExcel,(c(paste("Test RMSE/Train RMSE =",round(RMSEtest/RMSEtrain,3),",   Test StdDev/Train StdDev =",round(sd(testValues)/sd(yValues),3)),rep("", 10),28)))   } else {writeLines("TEST SET IS EMPTY")outputExcel  <-  rbind(outputExcel,(c(rep("", 12))))} colnames(outputExcel) <- rep("",12) rownames(outputExcel) <- rep("",nrow(outputExcel)) outputExcel <- rbind(outputExcel,cbind(trainTableExport,c(31,37,38,rep(39,dim(trainTableExport)[1]-3))))outputExcel <- rbind(outputExcel,cbind(testTableExport,c(41,42,43,rep(44,dim(testTableExport)[1]-3)))) write.table(outputExcel, "clipboard-10000", sep="\t", row.names=FALSE,col.names=FALSE)modelSummaryTable <- rbind("",nTrain,nVariables-constantInd,RMSEtrain,RMSEnull,modelAdjRsquared,nTest,RMSEtest,RMSEtest/RMSEtrain,RMSEnulltest,1-(RMSEtest/RMSEnulltest)^2)modelSummaryDigits <- c(0,0,RMSEdigits,RMSEdigits,3,1,RMSEdigits,3, RMSEdigits,3)modelSummaryTableExport <- cbind(c("Iteration","#Train","#Vars","TrainRMSE","ConstRMSE","Adj.R-Sqr.","#Test","TestRMSE","Test/Train","TestConst","R-Sqr."),modelSummaryTable)modelSummaryTableExport <- rbind(c(modelName,yName, rep("",ncol(modelSummaryTableExport)-2)),modelSummaryTableExport)writeLines("")writeLines(modelDescription)writeLines(variableSelection)writeLines(testMethod)writeLines(" ");writeLines(" "); writeLines("***The output for this model has been written to the clipboard for importing to Excel.***"); writeLines("Go back to your Excel file and hit the Import R button on the RegressIt menu to insert it on a new worksheet and add its statistics to the Model Summaries worksheet.")writeLines(" ")writeLines(" -----End script GLOWdata3.Model.3.04.29.22.37.34.r produced by RegressItLogistic version 2022.12.14 on DESKTOP-F9IAE9K at time 04.29.22.37.34")writeLines("Various model inputs and outputs have been stored in global objects with generic names such as modelEquation, coeffMatrix, trainData (variables), trainTable (predictions, errors, etc.), testData and testTable (if any), and many others.")writeLines("They can all be deleted via the Clear Variables tool on the R code menu in RegressIt.")writeLines("Copy and paste the following line at the command prompt to re-run the script."); writeLines(" source('C:/Users/Jessica M/Desktop/GLOWdata3.Model.3.04.29.22.37.34.r', encoding = 'UTF-8') ")
