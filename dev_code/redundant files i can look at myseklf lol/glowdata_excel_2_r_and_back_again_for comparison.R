suppressWarnings(rm(a,adStats,anovaDF,anovaMatrix,anovaTable,autocorrBarPlowriteLines(" ")modelDescription <- "Logistic regression model STATS.3.LOGISTIC for FRACTURE in data frame GLOWdata3 " writeLines(modelDescription)variableSelection <- "Variable selection:  forward stepwise " writeLines(variableSelection)testMethod <- "Out-of-sample test:  none " writeLines(testMethod)regData <- GLOWdata3regY <- GLOWdata3$FRACTUREnData <- nrow(regData)regScript <- "GLOWdata3.STATS.3.LOGISTIC.04.29.22.54.29.r"yName <- "FRACTURE"# ----- setup for a model with no out-of-sample testrowNumbers <- 1:nData  trainSet <- rowNumberstrainData <- regData[trainSet,]nTrain <- nDatanTest <- 0STATS.3.LOGISTIC <- glm(FRACTURE ~ __adj__AGE_STDZxNOPRIOR + __adj__AGE_STDZxPRIOR + __adj__ARMASSIST + __adj__BMI + __adj__HEIGHT + __adj__MOMFRAC + __adj__MOMFRACxARMASSIST + __adj__PREMENO + __adj__RATERISK_EQ_3 + __adj__SMOKE + __adj__WEIGHT, family = binomial, data = trainData)constantInd <- 1STATS.3.LOGISTIC.allvariables <- STATS.3.LOGISTIC# ----- before stepwise selection, fit the all-variable model and then remove rows with missing values of predictions or dependent variabletrainPred <- predict(STATS.3.LOGISTIC.allvariables, trainData, se.fit= T, type = "response", interval = "prediction", level = .95)trainErrors <- residuals(STATS.3.LOGISTIC.allvariables, trainData, type = "response", interval = "prediction", level = .95)trainTable <- na.omit(cbind(trainSet, regY[trainSet], trainPred$fit, trainPred$se.fit))trainTable <- na.omit(cbind(trainTable,trainErrors))trainSet <- trainTable[,1]trainData <-  regData[trainSet,]writeLines(" ")writeLines(paste("# rows with any missing values removed prior to stepwise selection = ", nTrain - dim(trainTable)[1] ))writeLines(" ")# ----- zero-variable logistic model as starting point for forward stepwise selectionnullModel <- glm(FRACTURE ~ 1, family=binomial, data = trainData)STATS.3.LOGISTIC <- step(nullModel,scope=list(lower=formula(nullModel),upper=formula(STATS.3.LOGISTIC.allvariables)),direction="forward")writeLines(paste("# variables removed by forward stepwise selection = ", STATS.3.LOGISTIC.allvariables$rank - STATS.3.LOGISTIC$rank))stepInfo <- paste(" ",STATS.3.LOGISTIC.allvariables$rank - STATS.3.LOGISTIC$rank,"removed by forward stepwise,")regModel <- STATS.3.LOGISTICmodelName <- "STATS.3.LOGISTIC" trainPred <- predict(regModel, trainData, se.fit= T, type = "response", interval = "prediction", level = .95)trainErrors <- residuals(regModel, trainData, type = "response", interval = "prediction", level = .95)# ----- table of training-set actual and predicted values, residuals, deviance residuals and Pearson's residuals# ----- deviance is the square of the deviance residualtrainTable <- cbind(na.omit(cbind(trainSet, regY[trainSet],trainPred$fit,regY[trainSet]-trainPred$fit)),residuals(regModel,type="deviance"),residuals(regModel,type="pearson"),hatvalues(regModel),cooks.distance(regModel)) # ----- more variables are created for later referencenMissing <- nTrain - dim(trainTable)[1]nTrain <- dim(trainTable)[1]yValues <- trainTable[,2]yFitted <- trainTable[,3]RMSEtrain <- (var(trainErrors) * (nTrain - 1) / nTrain + mean(trainErrors) ^ 2) ^ 0.5RMSEdigits <- max(0, round(4 - log10(RMSEtrain)))   # number of significant digits to use for rounding some statistics in tablesRMSEnull <- (var(yValues)* (nTrain - 1) / nTrain) ^ 0.5 colnames(trainTable) <- c("Train Row#", "Actual", "Predicted", "Residual","Deviance.Res.", "Pearson.Res.", "Leverage", "Cooks D")nVariables <- regModel$rankmodelInfo <- paste(modelName,"for",yName,"(",nVariables - constantInd,"variable(s),",stepInfo,"n=",nTrain,")")residualDf <- regModel$df.residualtValue <- qt(0.975, residualDf)modelDf <- regModel$df.null - regModel$df.residualmodelDev <- regModel$null.deviance - regModel$deviancemodelRsquared <- 1 - regModel$deviance/regModel$null.deviancemodelAdjRsquared <- max(0,1 - (regModel$deviance + 2*(modelDf + 1))/regModel$null.deviance)# ----- build the optional analysis-of-deviance tableanovaTable  <- c("Analysis of deviance",rep("", 8)) anovaTable  <- rbind(anovaTable,rep("",9)) anovaTable  <- rbind(anovaTable,(c("Source   ","Df ","Deviance","P(ChiSq > Reg.Dev.)",rep("",5)))) anovaTable  <- rbind(anovaTable,(c("Regression   ",modelDf,round(modelDev,2),format(round(pchisq(modelDev, df=modelDf, lower.tail=FALSE),3),nsmall = 3),rep("",5)))) anovaTable  <- rbind(anovaTable,(c("Residual   ",regModel$df.residual,round(regModel$deviance,2),rep("",6)))) anovaTable  <- rbind(anovaTable,(c("Null   ",regModel$df.null,round(regModel$null.deviance,2),rep("",6)))) colnames(anovaTable) <- rep("", 9)rownames(anovaTable) <- rep("", 6)anovaMatrix  <- c(modelDf,round(modelDev,2),round(pchisq(modelDev, df=modelDf, lower.tail=FALSE),3))anovaMatrix   <- rbind(anovaMatrix ,c(regModel$df.residual,round(regModel$deviance,2),NA))anovaMatrix  <- rbind(anovaMatrix,c(regModel$df.null,round(regModel$null.deviance,2),NA)) row.names(anovaMatrix) <- c("Regression","Residual","Null")modelMASE <- NAwriteLines(" ")print(regModel$call)writeLines(" ")writeLines(paste("Regression statistics:",modelName,"for",yName,"(#variables =",nVariables-1,")"))roccurve <- roc(yValues  ~ yFitted, data = trainData)logitStats  <- t(matrix(c(modelRsquared,modelAdjRsquared,regModel$df.residual,RMSEtrain,mean(yValues),nTrain,nMissing,roccurve$auc,summary.glm(regModel)$aic))) print(kable(logitStats, col.names = c("R-Sqr","Adj R-Sqr","Df","RMSE","Mean","#Fitted","#Missing","ROC area","AIC"),digits = c(3,3,0,4,4,0,0,3,3)))writeLines("") expCoeff <- exp(summary.glm(regModel)$coefficients[,1])# ----- calculate variance inflation factors if the model includes a constant and has more than one independent variablevifValues <- NA if(grepl("Int", variable.names(regModel)[1]) & nVariables > 1){   vifValues <- c(0,vif(regModel))   } coeffTable  <-   cbind(summary.glm(regModel)$coefficients[,c(1,2)],round(summary.glm(regModel)$coefficients[,c(3,4)],6),na.omit(confint.default(regModel, level =.95)),vifValues,expCoeff) writeLines("Coefficient estimates:") cDigits <- max(pmax(0,round(3 - log10(as.numeric(coeffTable[,2])),0)))rownames(coeffTable) <- variable.names(regModel)coeffTable <-gsub("_","|",kable(coeffTable, col.names = c("Coeff","StdErr","z stat","P(>_z_)","Lower95%","Upper95%","VIF","ExpCoeff"),digits = c(cDigits,cDigits,3,3,cDigits,cDigits,1,3)))coeffTable <- gsub("NA","  ",coeffTable)coeffStars <- stars.pval(summary.glm(regModel)$coefficients[,4])[1:nVariables]   #  add coefficient stars to next to variable names, not P-valuescoeffTable <- data.frame(cbind(c("","",coeffStars),coeffTable))   colnames(coeffTable) <- NULLprint(coeffTable, row.names = F)writeLines(" ")writeLines("Analysis of deviance:")print(gsub("NA","  ",kable(anovaMatrix,col.names=c("Df","Deviance","P(Dev<ChiSq)"),digits = c(1,3,3))))writeLines(" ")writeLines("Correlation matrix of coefficient estimates ")writeLines(" ")print(cov2cor(vcov(regModel)))# ----- build single-row table of error statistics in training period errorStats <- t(matrix(c(nTrain,mean(trainTable[,2]),RMSEtrain,RMSEnull,RMSEtrain/RMSEnull,RMSEtrain^2)))rownames(errorStats) <- yNameif(nTest>0){# ----- add 2nd row with error statistics in test period errorStats <- rbind(errorStats,c(nTest,mean(na.omit(testTable[,2])),RMSEtest,RMSEnulltest,RMSEtest/RMSEnulltest,RMSEtest^2))rownames(errorStats) <- c("Train","Test")}writeLines(" ")writeLines("Comparative error statistics:")print(kable(errorStats, col.names = c("#","Mean","ModelRMSE","ConstRMSE","Model/Const","MSE(BrierScore)"),digits= c(0,4,4,4,2,4)))writeLines(" ")if(nTest>0){writeLines("The test set constant model is based on the mean of the dependent variable in the test set.")}writeLines(" ")cutoffValue <- 0.5writeLines(" ")writeLines(paste("Classification accuracy with cutoff value = ",cutoffValue))writeLines("Training set: ")trainClass <- table(yValues, fitted(regModel) > cutoffValue)if(as.vector(dim(trainClass)[1])==1){if(rownames(trainClass)[1] == "FALSE") { trainClass <- rbind(trainClass,c(0,0)) } else {trainClass <- rbind(c(0,0),trainClass)}}if(as.vector(dim(trainClass)[2])==1){if(colnames(trainClass)[1] == "FALSE") { trainClass <- cbind(trainClass,c(0,0))} else {trainClass <- cbind(c(0,0),trainClass)}}rownames(trainClass ) <- c("Actual: 0","        1")colnames(trainClass ) <- c("Predicted: 0","   1")trainPctCor <- round((trainClass [1, 1] + trainClass [2, 2]) / sum(trainClass ), 4)trainTruePos <- round(trainClass [2, 2]/ sum(trainClass [2,]), 4)trainTrueNeg <- round(trainClass [1, 1]/sum(trainClass [1,]), 4)trainClass <- cbind(trainClass , Total = rowSums(trainClass ))trainClass <- rbind(trainClass , Total = colSums(trainClass ))trainStats <- trainClassrownames(trainStats) <- rep(" ",3)  colnames(trainStats) <- rep(" ",3) trainStatsExport <- rbind(c("Predict 0","Predict 1","Total","","","Predict 0","Predict 1","Total"),cbind(trainStats,matrix("",nrow=3,ncol=2),trainStats/trainStats[3,3]))trainStatsExport <- cbind(c("Training results","Actual 0","Actual 1","Total"),trainStatsExport)trainStats <- rbind(c("Predict 0","Predict 1","Total","","","Predict 0","Predict 1","Total"),cbind(trainStats,matrix("",nrow=3,ncol=2),round(trainStats/trainStats[3,3],3)))trainStats <- cbind(c("Training results","Actual 0","Actual 1","Total"),trainStats)trainStatsExport <- rbind(trainStatsExport,rep("",9),c("Fraction correct",trainPctCor,"","RMSE train","","","","",""))trainStatsExport <- rbind(trainStatsExport,c("True positive rate",trainTruePos,"","RMSE const","","","","",""))trainStatsExport <- rbind(trainStatsExport,c("True negative rate",trainTrueNeg,"","Cutoff value","","","","",""))trainStatsExport[6:8,5] <- c(RMSEtrain,RMSEnull,cutoffValue)trainStatsExport[1:4,6] <- c("Fraction","Actual 0","Actual 1","Total")trainStats[1:4,6] <- c("Fraction","Actual 0","Actual 1","Total")trainStatsValues <- trainStats[2:4,2:9]rownames(trainStatsValues) <- c("Actual 0","Actual 1","Total")print(kable(trainStatsValues,col.names=c("Predict 0","Predict 1","Total","","Fraction","Predict 0","Predict 1","Total")))writeLines(" ")trainStats <- rbind(c(paste("Training set classification accuracy with cutoff value = ",cutoffValue,":"),"","","","","","","",""),trainStats)trainStats <- rbind(rep("",9),trainStats)trainStatsExport <- rbind(c(paste("Training Set Classification Accuracy With Cutoff Value = ",cutoffValue,":",modelInfo),"","","","","","","",""),trainStatsExport)trainStatsExport <- rbind(rep("",9),trainStatsExport)classStats <- t(matrix(c(nTrain,trainPctCor,trainTruePos,trainTrueNeg)))rownames(classStats) <- yNameif(nTest>0){classStats <- rbind(classStats,c(nTest,testPctCor,testTruePos,testTrueNeg))rownames(classStats) <- c("Train","Test")}writeLines(" ")writeLines("Overall accuracy:")print(kable(classStats, col.names = c("#","Correct","True Pos","True Neg"),digits = c(0,rep(3,3))))writeLines(" ")testTitle = " " trainSetName = " " testSetName = " " mainTitle = paste(modelName," for ",yName,testTitle)modelSize <- paste("n=", nTrain, ", #var=",length(regModel$coefficients)-1,", ")layout(matrix(c(1,2,3,4),2,2))plot(regModel, main = mainTitle, cex.main = 0.95)layout(matrix(c(1,2,3),3,1))yMin = min(na.omit(regY),yValues,yFitted)yMax = max(na.omit(regY),yValues,yFitted)plot(trainTable[,1],yValues,main=mainTitle, type = "o", col = "black",lty=0, xlab = NA , ylab= yName, cex.main = 0.95, ylim = c(yMin,yMax))title(main = (paste(modelSize, trainSetName, "RMSE=",round(RMSEtrain,RMSEdigits))),  line = 0.5, cex.main = 0.8)points(trainTable[,1],yFitted,pch = 16, col = "red",cex=1)barplot(yValues- yFitted,main=mainTitle,xlab = NA, ylab= "Residual", cex.main=0.95,ylim = c(-1,1))title(sub = paste(modelSize, trainSetName, "RMSE=",round(RMSEtrain,RMSEdigits)), cex.sub = 0.8)writeLines(" ")trainPred <- predict(regModel,type=c("response"))plot(roccurve, asp = NA,legacy.axes = TRUE,main = paste (mainTitle, " AUC = ", round(print(roccurve$auc),3)))  # ----- build a text string with the model equationmodelEquation <- paste("STATS.3.LOGISTIC <- glm(",as.character(formula(STATS.3.LOGISTIC)[2])," ~ ",paste(names(coef(STATS.3.LOGISTIC)), collapse='+'),",family = binomial,data = GLOWdata3)") modelEquation <- sub("(Intercept)+","",modelEquation,fixed=TRUE)#  ----- start building 9-column matrix of output for ExceloutputExcel  <- c("Model:", modelName,rep("",2),"Mean:","R Script:",regScript,rep("",4),1) outputExcel  <- rbind(outputExcel,(c("Binary Dependent Variable:","",yName,rep("",2),testMethod,rep("",5),2))) outputExcel  <- rbind(outputExcel,(c("Independent Variables:",rep("",4),variableSelection,rep("",5),3))) indVariables <- paste(names(coef(regModel)),collapse = ",") indVariables <- sub("(),","",indVariables) indVariables <- gsub("\\(","",indVariables) indVariables <- gsub("\\)","",indVariables) outputExcel  <- rbind(outputExcel,(c(indVariables,rep("" ,10),4))) outputExcel  <- rbind(outputExcel,(c("Equation:",rep("", 10),5))) outputExcel  <- rbind(outputExcel,(c(modelEquation,rep("", 10),6))) outputExcel  <- rbind(outputExcel,(c(rep("", 12)))) outputExcel  <- rbind(outputExcel,(c(paste("Logistic Regression Statistics:",modelInfo),rep("", 10),8))) outputExcel  <- rbind(outputExcel,(c("R-Squared","Adj.R-Sqr.","RMSE","Mean","#Fitted","ROC area","AIC",rep("",4),9))) outputExcel  <- rbind(outputExcel,(c(modelRsquared,modelAdjRsquared,RMSEtrain,mean(yValues),summary.glm(regModel)$df[2]+summary.glm(regModel)$df[1],roccurve$auc,summary.glm(regModel)$aic,rep("",4),10))) outputExcel  <- rbind(outputExcel,(c(rep("", 12)))) outputExcel  <- rbind(outputExcel,(c(paste("Coefficient Estimates:",modelInfo),rep("", 10),12))) outputExcel  <- rbind(outputExcel,(c("Variable","Coefficient","Std.Err.","z statistic","P value","Lower95%","Upper95%","VIF","Exp.Coeff.","","",13))) coeffTableExcel  <-  cbind(variable.names(regModel),summary.glm(regModel)$coefficients[,c(1,2)],summary.glm(regModel)$coefficients[,c(3,4)],na.omit(confint.default(regModel, level =.95)),vifValues,expCoeff) outputExcel[4,] <- sub("Intercept","", outputExcel[4,]) coeffTableExcel[1,] <- sub("(Intercept)", "Constant",coeffTableExcel[1,]) coeffTableExcel[1,] <- gsub("\\(", " ", coeffTableExcel[1,]) coeffTableExcel <- gsub("\\)", ".Eq.", coeffTableExcel) coeffTableExcel[1,] <- sub("Constant.Eq.", "Constant",coeffTableExcel[1,]) coeffTableExcel <- gsub("\\(", "", coeffTableExcel) coeffTableExcel <- sub("factor", "", coeffTableExcel) coeffTableExcel <- cbind(coeffTableExcel,rep("",nVariables),rep("",nVariables),rep(14,nVariables)) outputExcel  <- rbind(outputExcel,coeffTableExcel) colnames(outputExcel) <- rep("",12) rownames(outputExcel) <- rep("",nrow(outputExcel)) outputExcel  <- rbind(outputExcel,(c(rep("", 12)))) outputExcel  <- rbind(outputExcel,(c(paste("Analysis of Deviance:",modelInfo),rep("", 10),16))) outputExcel  <- rbind(outputExcel,(c("Source   ","Deg.Freedom","Deviance","P-value",rep("",7),17))) outputExcel  <- rbind(outputExcel,(c("Regression   ",modelDf,modelDev,pchisq(modelDev, df=modelDf, lower.tail=FALSE),rep("",7),18))) outputExcel  <- rbind(outputExcel,(c("Residual   ",regModel$df.residual,regModel$deviance,rep("",8),19))) outputExcel  <- rbind(outputExcel,(c("Null   ",regModel$df.null,regModel$null.deviance,rep("",8),20))) outputExcel  <- rbind(outputExcel,(c(rep("", 12)))) outputExcel  <- rbind(outputExcel,(c(paste("Comparative error statistics:",modelInfo),rep("", 10),50))) outputExcel  <- rbind(outputExcel,c("","#","Mean","Model RMSE","Const RMSE","RMSE ratio","       MSE(Brier score)",rep("",4),51))if(nTest == 0){outputExcel  <- rbind(outputExcel,c(yName,errorStats[1:6],rep("",4),52))} else {outputExcel  <- rbind(outputExcel,c("Train",errorStats[1,1:6],rep("",4),52))outputExcel  <- rbind(outputExcel,c("Test",errorStats[2,1:6],rep("",4),53))outputExcel  <- rbind(outputExcel,(c(rep("", 12)))) outputExcel  <- rbind(outputExcel,(c(testMethod,rep("", 10),55)))}outputExcel  <- rbind(outputExcel,(c(rep("", 12)))) outputExcel  <- rbind(outputExcel,cbind(trainStatsExport,rep("",10),rep("",10),c(58:67)))write.table(outputExcel, "clipboard-10000", sep="\t", row.names=FALSE,col.names=FALSE)modelSummaryTable <- rbind("",nTrain,nVariables-constantInd,RMSEtrain,modelAdjRsquared, roccurve$auc,cutoffValue,trainPctCor,trainTruePos,trainTrueNeg)modelSummaryDigits <- c(0,0,RMSEdigits,3,2,2,2,2,2)modelSummaryTableExport <- cbind(c("Iteration","#Fitted","#Vars","RMSE","R-Sqr.","ROC area","Cutoff","Correct","TruePos","TrueNeg"),modelSummaryTable)writeLines("")writeLines(modelDescription)writeLines(variableSelection)writeLines(testMethod)writeLines(" ");writeLines(" "); writeLines("***The output for this model has been written to the clipboard for importing to Excel.***"); writeLines(writeLines(" -----End script GLOWdata3.STATS.3.LOGISTIC.04.29.22.54.29.r writeLines("Various model inputs and outputs have been stored in global objects with generic names such as modelEquation, coeffMatrix, trainData (variables), trainTable (predictions, errors, etc.), testData and testTable (if any), and many others.")writeLines("They can all be deleted via the Clear Variables tool on the R codewriteLines("Copy and paste the following line at the command prompt to re-run the script."); writeLines(" source('C:/Users/Jessica M/Desktop/GLOWdata3.STATS.3.LOGISTIC.04.29.22.54.29.r', encoding = 'UTF-8') ")